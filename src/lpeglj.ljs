/*
LPEGLJ
lpeglj.lua
Main module and tree generation
Copyright (C) 2014 Rostislav Sacek.
based on LPeg v1.0 - PEG pattern matching for Lua
Lua.org & PUC-Rio  written by Roberto Ierusalimschy
http://www.inf.puc-rio.br/~roberto/lpeg/

** Permission is hereby granted, free of charge, to any person obtaining
** a copy of this software and associated documentation files (the
** "Software"), to deal in the Software without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Software, and to
** permit persons to whom the Software is furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be
** included in all copies or substantial portions of the Software.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
**
** [ MIT license: http://www.opensource.org/licenses/mit-license.php ]
--*/

assert(jit.version_num > 20000, "Use LuaJIT v2.0.1 or higher.");

var ffi = require ("ffi");
var lpcode = require ("lpcode");
var lpprint = require ("lpprint");
var lpvm = require ("lpvm");

var band, bor, bnot, rshift, lshift = bit.band, bit.bor, bit.bnot, bit.rshift, bit.lshift;

ffi.cdef ([=[
 int isalnum(int c);
 int isalpha(int c);
 int iscntrl(int c);
 int isdigit(int c);
 int isgraph(int c);
 int islower(int c);
 int isprint(int c);
 int ispunct(int c);
 int isspace(int c);
 int isupper(int c);
 int isxdigit(int c);
]=]);

var MAXBEHIND = 255;
var MAXRULES = 200;
var VERSION = "1.0.0.0LJ";

var TChar = 0;
var TSet = 1;
var TAny = 2; // standard PEG elements
var TTrue = 3;
var TFalse = 4;
var TRep = 5;
var TSeq = 6;
var TChoice = 7;
var TNot = 8;
var TAnd = 9;
var TCall = 10;
var TOpenCall = 11;
var TRule = 12; // sib1 is rule's pattern, sib2 is 'next' rule
var TGrammar = 13; // sib1 is initial (and first) rule
var TBehind = 14; // match behind
var TCapture = 15; // regular capture
var TRunTime = 16; // run-time capture

var IAny = 0; // if no char, fail
var IChar = 1; // if char != val, fail
var ISet = 2; // if char not in val, fail
var ITestAny = 3; // in no char, jump to 'offset'
var ITestChar = 4; // if char != val, jump to 'offset'
var ITestSet = 5; // if char not in val, jump to 'offset'
var ISpan = 6; // read a span of chars in val
var IBehind = 7; // walk back 'val' characters (fail if not possible)
var IRet = 8; // return from a rule
var IEnd = 9; // end of pattern
var IChoice = 10; // stack a choice; next fail will jump to 'offset'
var IJmp = 11; // jump to 'offset'
var ICall = 12; // call rule at 'offset'
var IOpenCall = 13; // call rule number 'offset' (must be closed to a ICall)
var ICommit = 14; // pop choice and jump to 'offset'
var IPartialCommit = 15; // update top choice to current position and jump
var IBackCommit = 16; // "fails" but jump to its own 'offset'
var IFailTwice = 17; // pop one choice and then fail
var IFail = 18; // go back to saved state on choice and jump to saved offset
var IGiveup = 19; // internal use
var IFullCapture = 20; // complete capture of last 'off' chars
var IOpenCapture = 21; // start a capture
var ICloseCapture = 22;
var ICloseRunTime = 23;

var Cclose = 0;
var Cposition = 1;
var Cconst = 2;
var Cbackref = 3;
var Carg = 4;
var Csimple = 5;
var Ctable = 6;
var Cfunction = 7;
var Cquery = 8;
var Cstring = 9;
var Cnum = 10;
var Csubst = 11;
var Cfold = 12;
var Cruntime = 13;
var Cgroup = 14;

var PEnullable = 0;
var PEnofail = 1;
var PEleftrecursion = 2;

var newgrammar;

var RuleLR = 0x10000;
var Ruleused = 0x20000;
var BCapcandelete = 0x30000;

var LREnable = false;

// number of siblings for each tree
var numsiblings = {
    0, 0, 0, // char, set, any
    0, 0, // true, false
    1, // rep
    2, 2, // seq, choice
    1, 1, // not, and
    0, 0, 2, 1, // call, opencall, rule, grammar
    1, // behind
    1, 1 // capture, runtime capture
};



var patternid = 0;
var valuetable = {};

var funcnames = setmetatable({}, { __mode = 'k' });

var treepatternelement = ffi.typeof('TREEPATTERN_ELEMENT');
var treepattern = ffi.typeof('TREEPATTERN');
var patternelement = ffi.typeof('PATTERN_ELEMENT');
var pattern = ffi.typeof('PATTERN');
var settype = ffi.typeof('int32_t[8]');
var uint32 = ffi.typeof('uint32_t[1]');

// Fix a TOpenCall into a TCall node, using table 'postable' to
// translate a key to its rule address in the tree. Raises an
// error if key does not exist.

var function fixonecall(postable, grammar, index, valuetable) {
    var name = valuetable[grammar.p[index].val]; // get rule's name
    var n = postable[name]; // query name in position table
    // no position?
    if( ! n ) {
        error(("rule '%s' undefined in given grammar")->format(type(name) == 'table' && '(a table)' || name), 0);
    }
    grammar.p[index].tag = TCall;
    grammar.p[index].ps = n - index; // position relative to node
    grammar.p[index + grammar.p[index].ps].cap = bit.bor(grammar.p[index + grammar.p[index].ps].cap, Ruleused);
}


// Transform left associative constructions into right
// associative ones, for sequence and choice; that is:
// (t11 + t12) + t2  =>  t11 + (t12 + t2)
// (t11 * t12) * t2  =>  t11 * (t12 * t2)
// (that is, Op (Op t11 t12) t2 => Op t11 (Op t12 t2))

var function correctassociativity(tree, index) {
    var t1 = index + 1;
    assert(tree.p[index].tag == TChoice || tree.p[index].tag == TSeq);
    while( tree.p[t1].tag == tree.p[index].tag ) {
        var n1size = tree.p[index].ps - 1; // t1 == Op t11 t12
        var n11size = tree.p[t1].ps - 1;
        var n12size = n1size - n11size - 1;
        for( i = 1, n11size ) {
            ffi.copy(tree.p + index + i, tree.p + t1 + i, ffi.sizeof(treepatternelement));
        }
        tree.p[index].ps = n11size + 1;
        tree.p[index + tree.p[index].ps].tag = tree.p[index].tag;
        tree.p[index + tree.p[index].ps].ps = n12size + 1;
    }
}


// Make final adjustments in a tree. Fix open calls in tree,
// making them refer to their respective rules or raising appropriate
// errors (if not inside a grammar). Correct associativity of associative
// constructions (making them right associative).

var function finalfix(fix, postable, grammar, index, valuetable) {

    var tag = grammar.p[index].tag;
    //subgrammars were already fixed
    if( tag == TGrammar ) {
        return;
    } else if( tag == TOpenCall ) {
        // inside a grammar?
        if( fix ) {
            fixonecall(postable, grammar, index, valuetable);
            // open call outside grammar
        } else {
            error(("rule '%s' used outside a grammar")->format(tostring(valuetable[grammar.p[index].val])), 0);
        }
    } else if( tag == TSeq || tag == TChoice ) {
        correctassociativity(grammar, index);
    }
    var ns = numsiblings[tag + 1];
    if( ns == 0 ) {
    } else if( ns == 1 ) {
        return finalfix(fix, postable, grammar, index + 1, valuetable);
    } else if( ns == 2 ) {
        finalfix(fix, postable, grammar, index + 1, valuetable);
        return finalfix(fix, postable, grammar, index + grammar.p[index].ps, valuetable);
    } else {
        assert(false);
    }
}


// {======================================================
// Tree generation
// =======================================================

var function newcharset() {
    var tree = treepattern(1);
    valuetable[tree.id] = { settype() };
    tree.p[0].tag = TSet;
    tree.p[0].val = 1;
    return tree, valuetable[tree.id][1];
}


// add to tree a sequence where first sibling is 'sib' (with size
// 'sibsize')

var function seqaux(tree, sib, start, sibsize) {
    tree.p[start].tag = TSeq;
    tree.p[start].ps = sibsize + 1;
    ffi.copy(tree.p + start + 1, sib.p, ffi.sizeof(treepatternelement) * sibsize);
}


// Build a sequence of 'n' nodes, each with tag 'tag' and 'val' got
// from the array 's' (or 0 if array is NULL). (TSeq is binary, so it
// must build a sequence of sequence of sequence...)

var function fillseq(tree, tag, start, n, s) {
    // initial n-1 copies of Seq tag; Seq ...
    for( i = 1, n - 1 ) {
        tree.p[start].tag = TSeq;
        tree.p[start].ps = 2;
        tree.p[start + 1].tag = tag;
        if( s ) {
            tree.p[start + 1].val = s->sub(i, i)->byte();
        }
        start +=   tree.p[start].ps;
    }
    tree.p[start].tag = tag; // last one does not need TSeq
    if( s ) {
        tree.p[start].val = s->sub(n, n)->byte();
    }
}


// Numbers as patterns:
// 0 == true (always match); n == TAny repeated 'n' times;
// -n == not (TAny repeated 'n' times)

var function numtree(n) {
    if( n == 0 ) {
        var tree = treepattern(1);
        tree.p[0].tag = TTrue;
        return tree;
    } else {
        var tree, start;
        if( n > 0 ) {
            tree = treepattern(2 * n - 1);
            start = 0;
            // negative: code it as !(-n)
        } else {
            n = -n;
            tree = treepattern(2 * n);
            tree.p[0].tag = TNot;
            start = 1;
        }
        fillseq(tree, TAny, start, n); // sequence of 'n' any's
        return tree;
    }
}


// Convert value to a pattern

var function getpatt(val, name) {
    var typ = type(val);
    if( typ == 'string' ) {
        // empty?
        if( #val == 0 ) {
            var pat = treepattern(1);
            pat.p[0].tag = TTrue; // always match
            return pat;
        } else {
            var tree = treepattern(2 * (#val - 1) + 1);
            fillseq(tree, TChar, 0, #val, val); // sequence of '#val' chars
            return tree;
        }
    } else if( typ == 'number' ) {
        return numtree(val);
    } else if( typ == 'boolean' ) {
        var pat = treepattern(1);
        pat.p[0].tag = val && TTrue || TFalse;
        return pat;
    } else if( typ == 'table' ) {
        return newgrammar(val);
    } else if( typ == 'function' ) {
        if( name && type(name) == 'string' ) {
            funcnames[val] = name;
        }
        var pat = treepattern(2);
        valuetable[pat.id] = { val };
        pat.p[0].tag = TRunTime;
        pat.p[0].val = 1;
        pat.p[1].tag = TTrue;
        return pat;
    } else if( ffi.istype(treepattern, val) ) {
        assert(val.treesize > 0);
        return val;
    }
    assert(false);
}

var function copykeys(ktable1, ktable2) {
    var ktable, offset = {}, 0;
    if( ! ktable1 && ! ktable2 ) {
        return ktable, 0;
    } else if( ktable1 ) {
        for( i = 1, #ktable1 ) {
            ktable[#ktable + 1] = ktable1[i];
        }
        offset = #ktable1;
        if( ! ktable2 ) {
            return ktable, 0;
        }
    }
    if( ktable2 ) {
        for( i = 1, #ktable2 ) {
            ktable[#ktable + 1] = ktable2[i];
        }
    }
    assert(#ktable < 65536, "too many Lua values in pattern");
    return ktable, offset;
}

var function correctkeys(tree, index, offset) {
    var tag = tree.p[index].tag;
    if( (tag == TSet || tag == TRule || tag == TCall || tag == TRunTime || tag == TOpenCall || tag == TCapture) &&
            tree.p[index].val != 0 ) {
        tree.p[index].val = tree.p[index].val + offset;
    }
    var ns = numsiblings[tag + 1];
    if( ns == 0 ) {
    } else if( ns == 1 ) {
        return correctkeys(tree, index + 1, offset);
    } else if( ns == 2 ) {
        correctkeys(tree, index + 1, offset);
        return correctkeys(tree, index + tree.p[index].ps, offset);
    } else {
        assert(false);
    }
}



// create a new tree, with a new root and one sibling.

var function newroot1sib(tag, pat) {
    var tree1 = getpatt(pat);
    var tree = treepattern(1 + tree1.treesize); // create new tree
    valuetable[tree.id] = copykeys(valuetable[tree1.id]);
    tree.p[0].tag = tag;
    ffi.copy(tree.p + 1, tree1.p, ffi.sizeof(treepatternelement) * tree1.treesize);
    return tree;
}


// create a new tree, with a new root and 2 siblings.

var function newroot2sib(tag, pat1, pat2) {
    var tree1 = getpatt(pat1);
    var tree2 = getpatt(pat2);
    var tree = treepattern(1 + tree1.treesize + tree2.treesize); // create new tree
    var ktable, offset = copykeys(valuetable[tree1.id], valuetable[tree2.id]);
    valuetable[tree.id] = ktable;
    tree.p[0].tag = tag;
    tree.p[0].ps = 1 + tree1.treesize;
    ffi.copy(tree.p + 1, tree1.p, ffi.sizeof(treepatternelement) * tree1.treesize);
    ffi.copy(tree.p + 1 + tree1.treesize, tree2.p, ffi.sizeof(treepatternelement) * tree2.treesize);
    if( offset > 0 ) {
        correctkeys(tree, 1 + tree1.treesize, offset);
    }
    return tree;
}


var function lp_P(val, name) {
    assert(type(val) != 'null');
    return getpatt(val, name);
}


// sequence operator; optimizations:
// false x => false, x true => x, true x => x
// (cannot do x . false => false because x may have runtime captures)

var function lp_seq(pat1, pat2) {
    var tree1 = getpatt(pat1);
    var tree2 = getpatt(pat2);
    //  false . x == false, x . true = x
    if( tree1.p[0].tag == TFalse || tree2.p[0].tag == TTrue ) {
        return tree1;
        // true . x = x
    } else if( tree1.p[0].tag == TTrue ) {
        return tree2;
    } else {
        return newroot2sib(TSeq, tree1, tree2);
    }
}


// choice operator; optimizations:
// charset / charset => charset
// true / x => true, x / false => x, false / x => x
// (x / true is not equivalent to true)

var function lp_choice(pat1, pat2) {
    var tree1 = getpatt(pat1);
    var tree2 = getpatt(pat2);
    var charset1 = lpcode.tocharset(tree1, 0, valuetable[tree1.id]);
    var charset2 = lpcode.tocharset(tree2, 0, valuetable[tree2.id]);
    if( charset1 && charset2 ) {
        var t, set = newcharset();
        for( i = 0, 7 ) {
            set[i] = bor(charset1[i], charset2[i]);
        }
        return t;
    } else if( lpcode.checkaux(tree1, PEnofail, 0) || tree2.p[0].tag == TFalse ) {
        return tree1; // true / x => true, x / false => x
    } else if( tree1.p[0].tag == TFalse ) {
        return tree2; // false / x => x
    } else {
        return newroot2sib(TChoice, tree1, tree2);
    }
}


// p^n

var function lp_star(tree1, n) {
    var tree;
    n = tonumber(n);
    assert(type(n) == 'number');
    // seq tree1 (seq tree1 ... (seq tree1 (rep tree1)))
    if( n >= 0 ) {
        tree = treepattern((n + 1) * (tree1.treesize + 1));
        if( lpcode.checkaux(tree1, PEnullable, 0) ) {
            error("loop body may accept empty string", 0);
        }
        valuetable[tree.id] = copykeys(valuetable[tree1.id]);
        var start = 0;
        // repeat 'n' times
        for( i = 1, n ) {
            seqaux(tree, tree1, start, tree1.treesize);
            start +=   tree.p[start].ps;
        }
        tree.p[start].tag = TRep;
        ffi.copy(tree.p + start + 1, tree1.p, ffi.sizeof(treepatternelement) * tree1.treesize);
        // choice (seq tree1 ... choice tree1 true ...) true
    } else {
        n = -n;
        // size = (choice + seq + tree1 + true) * n, but the last has no seq
        tree = treepattern(n * (tree1.treesize + 3) - 1);
        valuetable[tree.id] = copykeys(valuetable[tree1.id]);
        var start = 0;
        // repeat (n - 1) times
        for( i = n, 2, -1 ) {
            tree.p[start].tag = TChoice;
            tree.p[start].ps = i * (tree1.treesize + 3) - 2;
            tree.p[start + tree.p[start].ps].tag = TTrue;
            ++start    ;
            seqaux(tree, tree1, start, tree1.treesize);
            start +=   tree.p[start].ps;
        }
        tree.p[start].tag = TChoice;
        tree.p[start].ps = tree1.treesize + 1;
        tree.p[start + tree.p[start].ps].tag = TTrue;
        ffi.copy(tree.p + start + 1, tree1.p, ffi.sizeof(treepatternelement) * tree1.treesize);
    }
    return tree;
}


// #p == &p

var function lp_and(pat) {
    return newroot1sib(TAnd, pat);
}


// -p == !p

var function lp_not(pat) {
    return newroot1sib(TNot, pat);
}


// [t1 - t2] == Seq (Not t2) t1
// If t1 and t2 are charsets, make their difference.

var function lp_sub(pat1, pat2) {
    var tree1 = getpatt(pat1);
    var tree2 = getpatt(pat2);
    var charset1 = lpcode.tocharset(tree1, 0, valuetable[tree1.id]);
    var charset2 = lpcode.tocharset(tree2, 0, valuetable[tree2.id]);
    if( charset1 && charset2 ) {
        var tree, set = newcharset();
        for( i = 0, 7 ) {
            set[i] = band(charset1[i], bnot(charset2[i]));
        }
        return tree;
    } else {
        var tree = treepattern(2 + tree1.treesize + tree2.treesize);
        var ktable, offset = copykeys(valuetable[tree2.id], valuetable[tree1.id]);
        valuetable[tree.id] = ktable;
        tree.p[0].tag = TSeq; // sequence of...
        tree.p[0].ps = 2 + tree2.treesize;
        tree.p[1].tag = TNot; // ...not...
        ffi.copy(tree.p + 2, tree2.p, ffi.sizeof(treepatternelement) * tree2.treesize);
        ffi.copy(tree.p + tree2.treesize + 2, tree1.p, ffi.sizeof(treepatternelement) * tree1.treesize);
        if( offset > 0 ) {
            correctkeys(tree, 2 + tree2.treesize, offset);
        }
        return tree;
    }
}


var function lp_set(val) {
    assert(type(val) == 'string');
    var tree, set = newcharset();
    for( i = 1, #val ) {
        var b = val->sub(i, i)->byte();
        set[rshift(b, 5)] = bor(set[rshift(b, 5)], lshift(1, band(b, 31)));
    }
    return tree;
}


var function lp_range(...) {
    var args = { ... };
    var top = #args;
    var tree, set = newcharset();
    for( i = 1, top ) {
        assert(#args[i] == 2, args[i] .. " range must have two characters");
        for( b = args[i]->sub(1, 1)->byte(), args[i]->sub(2, 2)->byte() ) {
            set[rshift(b, 5)] = bor(set[rshift(b, 5)], lshift(1, band(b, 31)));
        }
    }
    return tree;
}


// Look-behind predicate

var function lp_behind(pat) {
    var tree1 = getpatt(pat);
    var n = lpcode.fixedlenx(tree1, 0, 0, 0);
    assert(! lpcode.hascaptures(tree1, 0), "pattern have captures");
    assert(n >= 0, "pattern may not have fixed length");
    assert(n <= MAXBEHIND, "pattern too long to look behind");
    var tree = newroot1sib(TBehind, pat);
    tree.p[0].val = n;
    return tree;
}


// Create a non-terminal

var function lp_V(val, p) {
    assert(val, "non-null value expected");
    var tree = treepattern(1);
    valuetable[tree.id] = { val };
    tree.p[0].tag = TOpenCall;
    tree.p[0].val = 1;
    tree.p[0].cap = p || 0;
    return tree;
}


// Create a tree for a non-empty capture, with a body and
// optionally with an associated value

var function capture_aux(cap, pat, val) {
    var tree = newroot1sib(TCapture, pat);
    tree.p[0].cap = cap;
    if( val ) {
        var ind = #valuetable[tree.id] + 1;
        assert(ind <= 65536, "too many Lua values in pattern" .. ind);
        valuetable[tree.id][ind] = val;
        tree.p[0].val = ind;
    }
    return tree;
}


// Fill a tree with an empty capture, using an empty (TTrue) sibling.

var function auxemptycap(tree, cap, par, start) {
    tree.p[start].tag = TCapture;
    tree.p[start].cap = cap;
    if( type(par) != 'null' ) {
        var ind = #valuetable[tree.id] + 1;
        assert(ind <= 65536, "too many Lua values in pattern");
        valuetable[tree.id][ind] = par;
        tree.p[start].val = ind;
    }
    tree.p[start + 1].tag = TTrue;
}


// Create a tree for an empty capture

var function newemptycap(cap, par) {
    var tree = treepattern(2);
    if( type(par) != 'null' ) { valuetable[tree.id] = {}; }
    auxemptycap(tree, cap, par, 0);
    return tree;
}


// Captures with syntax p / v
// (function capture, query capture, string capture, or number capture)

var function lp_divcapture(pat, par, xxx) {
    var typ = type(par);
    if( typ == "function" ) {
        return capture_aux(Cfunction, pat, par);
    } else if( typ == "table" ) {
        return capture_aux(Cquery, pat, par);
    } else if( typ == "string" ) {
        return capture_aux(Cstring, pat, par);
    } else if( typ == "number" ) {
        var tree = newroot1sib(TCapture, pat);
        assert(0 <= par && par <= 0xffff, "invalid number");
        tree.p[0].cap = Cnum;
        var ind = #valuetable[tree.id] + 1;
        assert(ind <= 65536, "too many Lua values in pattern");
        valuetable[tree.id][ind] = par;
        tree.p[0].val = ind;
        return tree;
    } else {
        error("invalid replacement value", 0);
    }
}


var function lp_substcapture(pat) {
    return capture_aux(Csubst, pat);
}


var function lp_tablecapture(pat) {
    return capture_aux(Ctable, pat, 0);
}


var function lp_groupcapture(pat, val) {
    if( ! val ) {
        return capture_aux(Cgroup, pat);
    } else {
        return capture_aux(Cgroup, pat, val);
    }
}


var function lp_foldcapture(pat, fce) {
    assert(type(fce) == 'function');
    return capture_aux(Cfold, pat, fce);
}


var function lp_simplecapture(pat) {
    return capture_aux(Csimple, pat);
}


var function lp_poscapture() {
    return newemptycap(Cposition);
}


var function lp_argcapture(val) {
    assert(type(val) == 'number');
    var tree = newemptycap(Carg, 0);
    var ind = #valuetable[tree.id] + 1;
    assert(ind <= 65536, "too many Lua values in pattern");
    valuetable[tree.id][ind] = val;
    tree.p[0].val = ind;
    assert(0 < val && val <= 0xffff, "invalid argument index");
    return tree;
}


var function lp_backref(val) {
    return newemptycap(Cbackref, val);
}


// Constant capture

var function lp_constcapture(...) {
    var tree;
    var args = { ... };
    var n = select('#', ...); // number of values
    // no values?
    if( n == 0 ) {
        tree = treepattern(1); // no capture
        tree.p[0].tag = TTrue;
    } else if( n == 1 ) {
        tree = newemptycap(Cconst, args[1]); // single constant capture
        // create a group capture with all values
    } else {
        tree = treepattern(3 + 3 * (n - 1));
        valuetable[tree.id] = {};
        tree.p[0].tag = TCapture;
        tree.p[0].cap = Cgroup;
        var start = 1;
        for( i = 1, n - 1 ) {
            tree.p[start].tag = TSeq;
            tree.p[start].ps = 3;
            auxemptycap(tree, Cconst, args[i], start + 1);
            start +=   tree.p[start].ps;
        }
        auxemptycap(tree, Cconst, args[n], start);
    }
    return tree;
}


var function lp_matchtime(pat, fce, name) {
    assert(type(fce) == 'function');
    if( name && type(name) == 'string' ) {
        funcnames[fce] = name;
    }
    var tree = newroot1sib(TRunTime, pat);
    var ind = #valuetable[tree.id] + 1;
    assert(ind <= 65536, "too many Lua values in pattern");
    valuetable[tree.id][ind] = fce;
    tree.p[0].val = ind;
    return tree;
}

// ======================================================



// ======================================================
// Grammar - Tree generation
// =======================================================


// return index and the pattern for the
// initial rule of grammar;
// also add that index into position table.

var function getfirstrule(pat, postab) {
    var key;
    // access first element
    if( type(pat[1]) == 'string' ) {
        key = pat[1];
    } else {
        key = 1;
    }
    var rule = pat[key];
    if( ! rule ) {
        error("grammar has no initial rule", 0);
    }
    // initial rule not a pattern?
    if( ! ffi.istype(treepattern, rule) ) {
        error(("initial rule '%s' is not a pattern")->format(tostring(key)), 0);
    }
    postab[key] = 1;
    return key, rule;
}


// traverse grammar, collect  all its keys and patterns
// into rule table. Create a new table (before all pairs key-pattern) to
// collect all keys and their associated positions in the final tree
// (the "position table").
// Return the number of rules and the total size
// for the new tree.

var function collectrules(pat) {
    var n = 1; // to count number of rules
    var postab = {};
    var firstkeyrule, firstrule = getfirstrule(pat, postab);
    var rules = { firstkeyrule, firstrule };
    var size = 2 + firstrule.treesize; // TGrammar + TRule + rule
    for( key, val in pairs(pat) ) {
        // initial rule?
        if( key != 1 && tostring(val) != tostring(firstrule) ) {
            // value is not a pattern?
            if( ! ffi.istype(treepattern, val) ) {
                error(("rule '%s' is not a pattern")->format(tostring(key)), 0);
            }
            rules[#rules + 1] = key;
            rules[#rules + 1] = val;
            postab[key] = size;
            size = 1 + size + val.treesize;
            ++n    ;
        }
    }
    ++size    ; // TTrue to finish list of rules
    return n, size, rules, postab;
}


var function buildgrammar(grammar, rules, n, index, valuetable) {
    var ktable, offset = {}, 0;
    // add each rule into new tree
    for( i = 1, n ) {
        var size = rules[i * 2].treesize;
        grammar.p[index].tag = TRule;
        grammar.p[index].cap = i; // rule number
        grammar.p[index].ps = size + 1; // point to next rule
        var ind = #ktable + 1;
        ktable[ind] = rules[i * 2 - 1];
        grammar.p[index].val = ind;
        ffi.copy(grammar.p + index + 1, rules[i * 2].p, ffi.sizeof(treepatternelement) * size); // copy rule
        ktable, offset = copykeys(ktable, valuetable[rules[i * 2].id]);
        if( offset > 0 ) {
            correctkeys(grammar, index + 1, offset);
        }
        index +=   grammar.p[index].ps; // move to next rule
    }
    grammar.p[index].tag = TTrue; // finish list of rules
    return ktable;
}


// Check whether a tree has potential infinite loops

var function checkloops(tree, index) {
    var tag = tree.p[index].tag;
    if( tag == TRep && lpcode.checkaux(tree, PEnullable, index + 1) ) {
        return true;
    } else if( tag == TGrammar ) {
        return; // sub-grammars already checked
    } else {
        tag = numsiblings[tree.p[index].tag + 1];
        if( tag == 0 ) {
            return;
        } else if( tag == 1 ) {
            return checkloops(tree, index + 1);
        } else if( tag == 2 ) {
            if( checkloops(tree, index + 1) ) {
                return true;
            } else {
                return checkloops(tree, index + tree.p[index].ps);
            }
        } else {
            assert(false);
        }
    }
}

// Check whether a rule can be left recursive; returns PEleftrecursion in that
// case; otherwise return 1 iff pattern is nullable.

var function verifyrule(rulename, tree, passed, nullable, index, valuetable) {
    var tag = tree.p[index].tag;
    if( tag == TChar || tag == TSet || tag == TAny || tag == TFalse ) {
        return nullable; // cannot pass from here
    } else if( tag == TTrue || tag == TBehind ) {
        return true;
    } else if( tag == TNot || tag == TAnd || tag == TRep ) {
        return verifyrule(rulename, tree, passed, true, index + 1, valuetable);
    } else if( tag == TCapture || tag == TRunTime ) {
        return verifyrule(rulename, tree, passed, nullable, index + 1, valuetable);
    } else if( tag == TCall ) {
        var rule = valuetable[tree.p[index].val];
        if( rule == rulename ) { return PEleftrecursion; }
        if( passed[rule] && passed[rule] > MAXRULES ) {
            return nullable;
        }
        return verifyrule(rulename, tree, passed, nullable, index + tree.p[index].ps, valuetable);
        // only check 2nd child if first is nullable
    } else if( tag == TSeq ) {
        var res = verifyrule(rulename, tree, passed, false, index + 1, valuetable);
        if( res == PEleftrecursion ) {
            return res;
        } else if( ! res ) {
            return nullable;
        } else {
            return verifyrule(rulename, tree, passed, nullable, index + tree.p[index].ps, valuetable);
        }
        // must check both children
    } else if( tag == TChoice ) {
        nullable = verifyrule(rulename, tree, passed, nullable, index + 1, valuetable);
        if( nullable == PEleftrecursion ) { return nullable; }
        return verifyrule(rulename, tree, passed, nullable, index + tree.p[index].ps, valuetable);
    } else if( tag == TRule ) {
        var rule = valuetable[tree.p[index].val];
        passed[rule] = (passed[rule] || 0) + 1;
        return verifyrule(rulename, tree, passed, nullable, index + 1, valuetable);
    } else if( tag == TGrammar ) {
        return lpcode.checkaux(tree, PEnullable, index); // sub-grammar cannot be left recursive
    } else {
        assert(false);
    }
}


var function verifygrammar(rule, index, valuetable) {
    // check left-recursive rules
    var LR = {};
    var ind = index + 1;
    while( rule.p[ind].tag == TRule ) {
        var rulename = valuetable[rule.p[ind].val];
        // used rule
        if( rulename ) {
            if( verifyrule(rulename, rule, {}, false, ind + 1, valuetable) == PEleftrecursion ) {
                if( ! LREnable ) {
                    error(("rule '%s' may be left recursive")->format(rulename), 0);
                }
                LR[rulename] = true;
            }
        }
        ind +=   rule.p[ind].ps;
    }
    assert(rule.p[ind].tag == TTrue);

    for( i = 0, rule.treesize - 1 ) {
        if( rule.p[i].tag == TRule && LR[valuetable[rule.p[i].val]] ) {
            rule.p[i].cap = bor(rule.p[i].cap, RuleLR); //TRule can be left recursive
        }
        if( rule.p[i].tag == TCall && LR[valuetable[rule.p[i].val]] ) {
            if( rule.p[i].cap == 0 ) {
                rule.p[i].cap = 1; //TCall can be left recursive
            }
        }
    }

    // check infinite loops inside rules
    ind = index + 1;
    while( rule.p[ind].tag == TRule ) {
        // used rule
        if( rule.p[ind].val ) {
            if( checkloops(rule, ind + 1) ) {
                error(("empty loop in rule '%s'")->format(tostring(valuetable[rule.p[ind].val])), 0);
            }
        }
        ind +=   rule.p[ind].ps;
    }
    assert(rule.p[ind].tag == TTrue);
}


// Give a name for the initial rule if it is not referenced

var function initialrulename(grammar, val, valuetable) {
    grammar.p[1].cap = bit.bor(grammar.p[1].cap, Ruleused);
    // initial rule is not referenced?
    if( grammar.p[1].val == 0 ) {
        var ind = #valuetable + 1;
        assert(ind <= 65536, "too many Lua values in pattern");
        valuetable[ind] = val;
        grammar.p[1].val = ind;
    }
}


function newgrammar(pat) {
    // traverse grammar. Create a new table (before all pairs key-pattern) to
    // collect all keys and their associated positions in the final tree
    // (the "position table").
    // Return new tree.

    var n, size, rules, postab = collectrules(pat);
    var grammar = treepattern(size);
    var start = 0;
    grammar.p[start].tag = TGrammar;
    grammar.p[start].val = n;
    valuetable[grammar.id] = buildgrammar(grammar, rules, n, start + 1, valuetable);
    finalfix(true, postab, grammar, start + 1, valuetable[grammar.id]);
    initialrulename(grammar, rules[1], valuetable[grammar.id]);
    verifygrammar(grammar, 0, valuetable[grammar.id]);
    return grammar;
}

// ======================================================

// remove duplicity from value table

var function reducevaluetable(p) {
    var vtable = valuetable[p.id];
    var value = {};
    var newvaluetable = {};

    var function check(v) {
        if( v > 0 ) {
            var ord = value[vtable[v]];
            if( ! ord ) {
                newvaluetable[#newvaluetable + 1] = vtable[v];
                ord = #newvaluetable;
                value[vtable[v]] = ord;
            }
            return ord;
        }
        return 0;
    }

    var function itertree(p, index) {
        var tag = p.p[index].tag;
        if( tag == TSet || tag == TCall || tag == TOpenCall ||
                tag == TRule || tag == TCapture || tag == TRunTime ) {
            p.p[index].val = check(p.p[index].val);
        }
        var ns = numsiblings[tag + 1];
        if( ns == 0 ) {
        } else if( ns == 1 ) {
            return itertree(p, index + 1);
        } else if( ns == 2 ) {
            itertree(p, index + 1);
            return itertree(p, index + p.p[index].ps);
        } else {
            assert(false);
        }
    }

    if( p.treesize > 0 ) {
        itertree(p, 0);
    }
    if( p.code != null ) {
        for( i = 0, p.code.size - 1 ) {
            var code = p.code.p[i].code;
            if( code == ICall || code == IJmp ) {
                p.code.p[i].aux = check(p.code.p[i].aux);
            } else if( code == ISet || code == ITestSet || code == ISpan ) {
                p.code.p[i].val = check(p.code.p[i].val);
            } else if( code == IOpenCapture || code == IFullCapture ) {
                p.code.p[i].offset = check(p.code.p[i].offset);
            }
        }
    }
    valuetable[p.id] = newvaluetable;
}


var function checkalt(tree) {
    var notchecked = {};
    var notinalternativerules = {};

    var function iter(tree, index, choice, rule) {
        var tag = tree[index].tag;
        if( tag == TCapture && bit.band(tree[index].cap, 0xffff) == Cgroup ) {
            if( ! choice ) {
                if( rule ) {
                    notchecked[rule] = index;
                }
            } else {
                tree[index].cap = bit.bor(tree[index].cap, BCapcandelete);
            }
        } else if( tag == TChoice ) {
            choice = true;
        } else if( tag == TRule ) {
            rule = tree[index].val;
            if( bit.band(tree[index].cap, 0xffff) - 1 == 0 ) {
                notinalternativerules[rule] = notinalternativerules[rule] || true;
            }
        } else if( tag == TCall ) {
            var r = tree[index].val;
            if( ! choice ) {
                notinalternativerules[r] = notinalternativerules[r] || true;
            }
        }
        var sibs = numsiblings[tree[index].tag + 1] || 0;
        if( sibs >= 1 ) {
            iter(tree, index + 1, choice, rule);
            if( sibs >= 2 ) {
                return iter(tree, index + tree[index].ps, choice, rule);
            }
        }
    }

    iter(tree, 0);
    for( k, v in pairs(notchecked) ) {
        if( ! notinalternativerules[k] ) {
            tree[v].cap = bit.bor(tree[v].cap, BCapcandelete);
        }
    }
}
var function prepcompile(p, index) {
    finalfix(false, null, p, index, valuetable[p.id]);
    checkalt(p.p);
    lpcode.compile(p, index, valuetable[p.id]);
    reducevaluetable(p);
    return p.code;
}


var function lp_printtree(pat, c) {
    assert(pat.treesize > 0);
    if( c ) {
        finalfix(false, null, pat, 0, valuetable[pat.id]);
    }
    lpprint.printtree(pat.p, 0, 0, valuetable[pat.id]);
}


var function lp_printcode(pat) {
    // not compiled yet?
    if( pat.code == null ) {
        prepcompile(pat, 0);
    }
    lpprint.printpatt(pat.code, valuetable[pat.id]);
}


// Main match function

var function lp_match(pat, s, init, ...) {
    var p = ffi.istype(treepattern, pat) && pat || getpatt(pat);
    p.code = p.code != null && p.code || prepcompile(p, 0);
    return lpvm.match(p, s, init, valuetable[p.id], ...);
}

var function lp_streammatch(pat, init, ...) {
    var p = ffi.istype(treepattern, pat) && pat || getpatt(pat);
    p.code = p.code != null && p.code || prepcompile(p, 0);
    return lpvm.streammatch(p, init, valuetable[p.id], ...);
}

// Only for testing purpose
// stream emulation (send all chars from string one char after char)
var function lp_emulatestreammatch(pat, s, init, ...) {
    var p = ffi.istype(treepattern, pat) && pat || getpatt(pat);
    p.code = p.code != null && p.code || prepcompile(p, 0);
    return lpvm.emulatestreammatch(p, s, init, valuetable[p.id], ...);
}

// {======================================================
// Library creation and functions not related to matching
// =======================================================

var function lp_setmax(val) {
    lpvm.setmax(val);
}

var function lp_setmaxbehind(val) {
    lpvm.setmaxbehind(val);
}

var function lp_enableleftrecursion(val) {
    LREnable = val;
}


var function lp_version() {
    return VERSION;
}


var function lp_type(pat) {
    if( ffi.istype(treepattern, pat) ) {
        return "pattern";
    }
}


var function createcat(tab, catname, catfce) {
    var t, set = newcharset();
    for( i = 0, 255 ) {
        if( catfce(i) != 0 ) {
            set[rshift(i, 5)] = bor(set[rshift(i, 5)], lshift(1, band(i, 31)));
        }
    }
    tab[catname] = t;
}


var function lp_locale(tab) {
    tab = tab || {};
    createcat(tab, "alnum", function(c) { return ffi.C.isalnum(c); });
    createcat(tab, "alpha", function(c) { return ffi.C.isalpha(c); });
    createcat(tab, "cntrl", function(c) { return ffi.C.iscntrl(c); });
    createcat(tab, "digit", function(c) { return ffi.C.isdigit(c); });
    createcat(tab, "graph", function(c) { return ffi.C.isgraph(c); });
    createcat(tab, "lower", function(c) { return ffi.C.islower(c); });
    createcat(tab, "print", function(c) { return ffi.C.isprint(c); });
    createcat(tab, "punct", function(c) { return ffi.C.ispunct(c); });
    createcat(tab, "space", function(c) { return ffi.C.isspace(c); });
    createcat(tab, "upper", function(c) { return ffi.C.isupper(c); });
    createcat(tab, "xdigit", function(c) { return ffi.C.isxdigit(c); });
    return tab;
}


var function lp_new(ct, size) {
    var pat = ffi.new(ct, size);
    pat.treesize = size;
    ++patternid    ;
    pat.id = patternid;
    return pat;
}


var function lp_gc(ct) {
    valuetable[ct.id] = null;
    if( ct.code != null ) {
        ffi.C.free(ct.code.p);
        ffi.C.free(ct.code);
    }
}

var function lp_eq(ct1, ct2) {
    return tostring(ct1) == tostring(ct2);
}

var function lp_load(str, fcetab) {
    var pat, t = lpvm.load(str, fcetab, true);
    valuetable[pat.id] = t;
    return pat;
}

var function lp_loadfile(fname, fcetab) {
    var pat, t = lpvm.loadfile(fname, fcetab, true);
    valuetable[pat.id] = t;
    return pat;
}

var function lp_dump(ct, tree) {
    var funccount = 0;
    // not compiled yet?
    if( ct.code == null ) {
        prepcompile(ct, 0);
    }
    var out = {};
    if( tree ) {
        out[#out + 1] = ffi.string(uint32(ct.treesize), 4);
        out[#out + 1] = ffi.string(ct.p, ffi.sizeof(treepatternelement) * ct.treesize);
    } else {
        out[#out + 1] = ffi.string(uint32(0), 4);
    }
    out[#out + 1] = ffi.string(uint32(ct.code.size), 4);
    out[#out + 1] = ffi.string(ct.code.p, ct.code.size * ffi.sizeof(patternelement));
    var t = valuetable[ct.id];
    var len = t && #t || 0;
    out[#out + 1] = ffi.string(uint32(len), 4);
    if( len > 0 ) {
        for( _, val in ipairs(t) ) {
            var typ = type(val);
            if( typ == 'string' ) {
                out[#out + 1] = 'str';
                out[#out + 1] = ffi.string(uint32(#val), 4);
                out[#out + 1] = val;
            } else if( typ == 'number' ) {
                val = tostring(val);
                out[#out + 1] = 'num';
                out[#out + 1] = ffi.string(uint32(#val), 4);
                out[#out + 1] = val;
            } else if( typ == 'cdata' ) {
                out[#out + 1] = 'cdt';
                out[#out + 1] = ffi.string(val, ffi.sizeof(val));
            } else if( typ == 'function' ) {
                out[#out + 1] = 'fnc';
                ++funccount    ;
                var name = funcnames[val] || ('FNAME%03d')->format(funccount);
                out[#out + 1] = ffi.string(uint32(#name), 4);
                out[#out + 1] = name;
                if( ! funcnames[val] && debug.getupvalue(val, 1) ) {
                    io.write(("Patterns function (%d) contains upvalue (%s) - use symbol name for function (%s).\n")->format(funccount, debug.getupvalue(val, 1), name), 0);
                }
                var data = string.dump(val, true);
                out[#out + 1] = ffi.string(uint32(#data), 4);
                out[#out + 1] = data;
            } else {
                error(("Type '%s' NYI for dump")->format(typ), 0);
            }
        }
    }
    return table.concat(out);
}

var function lp_save(ct, fname, tree) {
    var file = assert(io.open(fname, 'wb'));
    file->write(lp_dump(ct, tree));
    file->close();
}


var pattreg = {
    ["ptree"] = lp_printtree,
    ["pcode"] = lp_printcode,
    ["match"] = lp_match,
    ["streammatch"] = lp_streammatch,
    ["emulatestreammatch"] = lp_emulatestreammatch,
    ["setmaxbehind"] = lp_setmaxbehind,
    ["B"] = lp_behind,
    ["V"] = lp_V,
    ["C"] = lp_simplecapture,
    ["Cc"] = lp_constcapture,
    ["Cmt"] = lp_matchtime,
    ["Cb"] = lp_backref,
    ["Carg"] = lp_argcapture,
    ["Cp"] = lp_poscapture,
    ["Cs"] = lp_substcapture,
    ["Ct"] = lp_tablecapture,
    ["Cf"] = lp_foldcapture,
    ["Cg"] = lp_groupcapture,
    ["P"] = lp_P,
    ["S"] = lp_set,
    ["R"] = lp_range,
    ["L"] = lp_and,
    ["locale"] = lp_locale,
    ["version"] = lp_version,
    ["setmaxstack"] = lp_setmax,
    ["type"] = lp_type,
    ["enableleftrecursion"] = lp_enableleftrecursion,
    ["enablememoization"] = lpvm.enablememoization,
    ["enabletracing"] = lpvm.enabletracing,
    ["save"] = lp_save,
    ["dump"] = lp_dump,
    ["load"] = lp_load,
    ["loadfile"] = lp_loadfile,
    ["__mul"] = lp_seq,
    ["__add"] = lp_choice,
    ["__pow"] = lp_star,
    ["__len"] = lp_and,
    ["__div"] = lp_divcapture,
    ["__unm"] = lp_not,
    ["__sub"] = lp_sub,
};

var metareg = {
    ["__gc"] = lp_gc,
    ["__new"] = lp_new,
    ["__mul"] = lp_seq,
    ["__add"] = lp_choice,
    ["__pow"] = lp_star,
    ["__len"] = lp_and,
    ["__div"] = lp_divcapture,
    ["__unm"] = lp_not,
    ["__sub"] = lp_sub,
    ["__eq"] = lp_eq,
    ["__index"] = pattreg
};

ffi.metatype(treepattern, metareg);

return pattreg;
