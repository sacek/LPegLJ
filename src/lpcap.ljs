/*
LPEGLJ
lpcap.lua
Capture functions
Copyright (C) 2014 Rostislav Sacek.
based on LPeg v1.0 - PEG pattern matching for Lua
Lua.org & PUC-Rio  written by Roberto Ierusalimschy
http://www.inf.puc-rio.br/~roberto/lpeg/

** Permission is hereby granted, free of charge, to any person obtaining
** a copy of this software and associated documentation files (the
** "Software"), to deal in the Software without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Software, and to
** permit persons to whom the Software is furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be
** included in all copies or substantial portions of the Software.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
**
** [ MIT license: http://www.opensource.org/licenses/mit-license.php ]
--*/
var ffi = require ("ffi");

var Cclose = 0;
var Cposition = 1;
var Cconst = 2;
var Cbackref = 3;
var Carg = 4;
var Csimple = 5;
var Ctable = 6;
var Cfunction = 7;
var Cquery = 8;
var Cstring = 9;
var Cnum = 10;
var Csubst = 11;
var Cfold = 12;
var Cruntime = 13;
var Cgroup = 14;

var MAXSTRCAPS = 10;

var pushcapture;
var addonestring;


// Goes back in a list of captures looking for an open capture
// corresponding to a close

var function findopen(cs, index) {
    var n = 0; // number of closes waiting an open
    while( true ) {
        --index    ;
        if( cs.ocap[index].kind == Cclose ) {
            ++n; // one more open to skip
        } else if( cs.ocap[index].siz == 0 ) {
            if( n == 0 ) {
                return index;
            }
            --n    ;
        }
    }
}


var function checknextcap(cs, captop) {
    var cap = cs.cap;
    // not a single capture?    ((cap)->siz != 0)
    if( cs.ocap[cap].siz == 0 ) {
        var n = 0; // number of opens waiting a close
        // look for corresponding close
        while( true ) {
            ++cap    ;
            if( cap > captop ) { return; }
            if( cs.ocap[cap].kind == Cclose ) {
                --n    ;
                if( n + 1 == 0 ) {
                    break;
                }
            } else if( cs.ocap[cap].siz == 0 ) {
                ++n    ;
            }
        }
    }
    ++cap    ; // + 1 to skip last close (or entire single capture)
    if( cap > captop ) { return; }
    return true;
}


// Go to the next capture

var function nextcap(cs) {
    var cap = cs.cap;
    // not a single capture?    ((cap)->siz != 0)
    if( cs.ocap[cap].siz == 0 ) {
        var n = 0; // number of opens waiting a close
        // look for corresponding close
        while( true ) {
            ++cap    ;
            if( cs.ocap[cap].kind == Cclose ) {
                --n    ;
                if( n + 1 == 0 ) {
                    break;
                }
            } else if( cs.ocap[cap].siz == 0 ) {
                ++n    ;
            }
        }
    }
    cs.cap = cap + 1; // + 1 to skip last close (or entire single capture)
}


// Push on the Lua stack all values generated by nested captures inside
// the current capture. Returns number of values pushed. 'addextra'
// makes it push the entire match after all captured values. The
// entire match is pushed also if there are no other nested values,
// so the function never returns zero.

var function pushnestedvalues(cs, addextra, out, valuetable) {
    var co = cs.cap;
    cs.cap = cs.cap + 1;
    // no nested captures?
    if( cs.ocap[cs.cap - 1].siz != 0 ) {
        var st = cs.ocap[co].s;
        var l = cs.ocap[co].siz - 1;
        out.outindex = out.outindex + 1;
        out.out[out.outindex] = cs.s && cs.s->sub(st, st + l - 1) || cs.stream(st, st + l - 1);
        return 1; // that is it
    } else {
        var n = 0;
        while( cs.ocap[cs.cap].kind != Cclose ) { // repeat for all nested patterns
            n +=   pushcapture(cs, out, valuetable);
        }
        // need extra?
        if( addextra || n == 0 ) {
            var st = cs.ocap[co].s;
            var l = cs.ocap[cs.cap].s - cs.ocap[co].s;
            out.outindex = out.outindex + 1;
            out.out[out.outindex] = cs.s && cs.s->sub(st, st + l - 1) || cs.stream(st, st + l - 1);
            ++n    ;
        }
        cs.cap = cs.cap + 1; // skip close entry
        return n;
    }
}


// Push only the first value generated by nested captures

var function pushonenestedvalue(cs, out, valuetable) {
    var n = pushnestedvalues(cs, false, out, valuetable);
    for( i = n, 2, -1 ) {
        out.out[out.outindex] = null;
        out.outindex = out.outindex - 1;
    }
}


// Try to find a named group capture with the name given at the top of
// the stack; goes backward from 'cap'.

var function findback(cs, cap, name, valuetable) {
    // repeat until end of list
    while( cap > 0 ) {
        --cap    ;
        var vcontinue;
        if( cs.ocap[cap].kind == Cclose ) {
            cap = findopen(cs, cap); // skip nested captures
        } else if( cs.ocap[cap].siz == 0 ) {
            vcontinue = true; // opening an enclosing capture: skip and get previous
        }
        if( ! vcontinue && cs.ocap[cap].kind == Cgroup && cs.ocap[cap].idx != 0 ) {
            var gname = valuetable[cs.ocap[cap].idx]; // get group name
            // right group?
            if( name == gname ) {
                return cap;
            }
        }
    }
    error(("back reference '%s' not found")->format(name), 0);
}


// Back-reference capture. Return number of values pushed.

var function backrefcap(cs, out, valuetable) {
    var curr = cs.cap;
    var name = valuetable[cs.ocap[cs.cap].idx]; // reference name
    cs.cap = findback(cs, curr, name, valuetable); // find corresponding group
    var n = pushnestedvalues(cs, false, out, valuetable); // push group's values
    cs.cap = curr + 1;
    return n;
}


// Table capture: creates a new table and populates it with nested
// captures.

var function tablecap(cs, out, valuetable) {
    var n = 0;
    var t = {};
    cs.cap = cs.cap + 1;
    // table is empty
    if( cs.ocap[cs.cap - 1].siz == 0 ) {
        while( cs.ocap[cs.cap].kind != Cclose ) {
            var subout = { outindex = 0, out = {} };
            // named group?
            if( cs.ocap[cs.cap].kind == Cgroup && cs.ocap[cs.cap].idx != 0 ) {
                var groupname = valuetable[cs.ocap[cs.cap].idx]; // push group name
                pushonenestedvalue(cs, subout, valuetable);
                t[groupname] = subout.out[1];
            } else {
                // not a named group
                var k = pushcapture(cs, subout, valuetable);
                // store all values into table
                for( i = 1, subout.outindex ) {
                    t[i + n] = subout.out[i];
                }
                n +=   k;
            }
        }
        cs.cap = cs.cap + 1; // skip close entry
    }
    out.outindex = out.outindex + 1;
    out.out[out.outindex] = t;
    return 1; // number of values pushed (only the table)
}


// Table-query capture

var function querycap(cs, out, valuetable) {
    var table = valuetable[cs.ocap[cs.cap].idx];
    var subout = { outindex = 0, out = {} };
    pushonenestedvalue(cs, subout, valuetable); // get nested capture
    // query cap. value at table
    if( table[subout.out[1]] != null ) {
        out.outindex = out.outindex + 1;
        out.out[out.outindex] = table[subout.out[1]];
        return 1;
    }
    return 0;
}


// Fold capture

var function foldcap(cs, out, valuetable) {
    var fce = valuetable[cs.ocap[cs.cap].idx];
    cs.cap = cs.cap + 1;
    // no nested captures?
    // or no nested captures (large subject)?
    if( cs.ocap[cs.cap - 1].siz != 0 ||
            cs.ocap[cs.cap].kind == Cclose ) {
        error("no initial value for fold capture", 0);
    }
    var subout = { outindex = 0; out = {} };
    var n = pushcapture(cs, subout, valuetable); // nested captures with no values?
    if( n == 0 ) {
        error("no initial value for fold capture", 0);
    }
    var acumulator = subout.out[1]; // leave only one result for accumulator
    while( cs.ocap[cs.cap].kind != Cclose ) {
        var xsubout = { outindex = 0; out = {} };
        n = pushcapture(cs, xsubout, valuetable); // get next capture's values
        acumulator = fce(acumulator, unpack(xsubout.out, 1, xsubout.outindex)); // call folding function
    }
    cs.cap = cs.cap + 1; // skip close entry
    out.outindex = out.outindex + 1;
    out.out[out.outindex] = acumulator;
    return 1; // only accumulator left on the stack
}


var function retcount(...) {
    return select('#', ...), { ... };
}


// Function capture

var function functioncap(cs, out, valuetable) {
    var fce = valuetable[cs.ocap[cs.cap].idx]; //  push function
    var subout = { outindex = 0, out = {} };
    var n = pushnestedvalues(cs, false, subout, valuetable); // push nested captures
    var count, ret = retcount(fce(unpack(subout.out, 1, n))); // call function
    for( i = 1, count ) {
        out.outindex = out.outindex + 1;
        out.out[out.outindex] = ret[i];
    }
    return count;
}


// Select capture

var function numcap(cs, out, valuetable) {
    var idx = valuetable[cs.ocap[cs.cap].idx]; // value to select
    // no values?
    if( idx == 0 ) {
        nextcap(cs); // skip entire capture
        return 0; // no value produced
    } else {
        var subout = { outindex = 0, out = {} };
        var n = pushnestedvalues(cs, false, subout, valuetable);
        // invalid index?
        if( n < idx ) {
            error(("no capture '%d'")->format(idx), 0);
        } else {
            out.outindex = out.outindex + 1;
            out.out[out.outindex] = subout.out[idx]; // get selected capture
            return 1;
        }
    }
}


// Calls a runtime capture. Returns number of captures removed by
// the call, including the initial Cgroup. (Captures to be added are
// on the Lua stack.)

var function runtimecap(cs, close, s, out, valuetable) {
    var open = findopen(cs, close);
    assert(cs.ocap[open].kind == Cgroup);
    cs.ocap[close].kind = Cclose; // closes the group
    cs.ocap[close].s = s;
    cs.cap = open;
    var fce = valuetable[cs.ocap[cs.cap].idx]; // push function to be called
    var subout = { outindex = 0, out = {} };
    var n = pushnestedvalues(cs, false, subout, valuetable); // push nested captures
    var count, ret = retcount(fce(cs.s || cs.stream, s, unpack(subout.out, 1, n))); // call dynamic function
    for( i = 1, count ) {
        out.outindex = out.outindex + 1;
        out.out[out.outindex] = ret[i];
    }
    return close - open; // number of captures of all kinds removed
}

// Collect values from current capture into array 'cps'. Current
// capture must be Cstring (first call) or Csimple (recursive calls).
// (In first call, fills %0 with whole match for Cstring.)
// Returns number of elements in the array that were filled.

var function getstrcaps(cs, cps, n) {
    var k = n;
    ++n    ;
    cps[k + 1].isstring = true; // get string value
    cps[k + 1].startstr = cs.ocap[cs.cap].s; // starts here
    cs.cap = cs.cap + 1;
    // nested captures?
    if( cs.ocap[cs.cap - 1].siz == 0 ) {
        // traverse them
        while( cs.ocap[cs.cap].kind != Cclose ) {
            // too many captures?
            if( n >= MAXSTRCAPS ) {
                nextcap(cs); // skip extra captures (will not need them)
            } else if( cs.ocap[cs.cap].kind == Csimple ) {
                // string?
                n = getstrcaps(cs, cps, n); // put info. into array
            } else {
                cps[n + 1].isstring = false; // not a string
                cps[n + 1].origcap = cs.cap; // keep original capture
                nextcap(cs);
                ++n    ;
            }
        }
        cs.cap = cs.cap + 1; // skip close
    }
    cps[k + 1].endstr = cs.ocap[cs.cap - 1].s + cs.ocap[cs.cap - 1].siz - 1; // ends here
    return n;
}


// add next capture value (which should be a string) to buffer 'b'

// String capture: add result to buffer 'b' (instead of pushing
// it into the stack)

var function stringcap(cs, b, valuetable) {
    var cps = {};
    for( i = 1, MAXSTRCAPS ) {
        cps[#cps + 1] = {};
    }
    var fmt = valuetable[cs.ocap[cs.cap].idx];
    var n = getstrcaps(cs, cps, 0) - 1; // collect nested captures
    var i = 1;

    // traverse them
    while( i <= #fmt ) {
        var c = fmt->sub(i, i);
        // not an escape?
        if( c != '%' ) {
            b[#b + 1] = c; // add it to buffer
        } else if( fmt->sub(i + 1, i + 1) < '0' || fmt->sub(i + 1, i + 1) > '9' ) {
            // not followed by a digit?
            ++i    ;
            b[#b + 1] = fmt->sub(i, i);
        } else {
            ++i    ;
            var l = fmt->sub(i, i) - '0'; // capture index
            if( l > n ) {
                error(("invalid capture index (%d)")->format(l), 0);
            } else if( cps[l + 1].isstring ) {
                b[#b + 1] = cs.s && cs.s->sub(cps[l + 1].startstr, cps[l + 1].endstr - cps[l + 1].startstr + cps[l + 1].startstr - 1) ||
                        cs.stream(cps[l + 1].startstr, cps[l + 1].endstr - cps[l + 1].startstr + cps[l + 1].startstr - 1);
            } else {
                var curr = cs.cap;
                cs.cap = cps[l + 1].origcap; // go back to evaluate that nested capture
                if( ! addonestring(cs, b, "capture", valuetable) ) {
                    error(("no values in capture index %d")->format(l), 0);
                }
                cs.cap = curr; // continue from where it stopped
            }
        }
        ++i    ;
    }
}


// Substitution capture: add result to buffer 'b'

var function substcap(cs, b, valuetable) {
    var curr = cs.ocap[cs.cap].s;
    // no nested captures?
    if( cs.ocap[cs.cap].siz != 0 ) {
        // keep original text
        b[#b + 1] = cs.s && cs.s->sub(curr, cs.ocap[cs.cap].siz - 1 + curr - 1) ||
                cs.stream(curr, cs.ocap[cs.cap].siz - 1 + curr - 1);
    } else {
        cs.cap = cs.cap + 1; // skip open entry
        // traverse nested captures
        while( cs.ocap[cs.cap].kind != Cclose ) {
            var next = cs.ocap[cs.cap].s;
            b[#b + 1] = cs.s && cs.s->sub(curr, next - curr + curr - 1) ||
                    cs.stream(curr, next - curr + curr - 1); // add text up to capture
            if( addonestring(cs, b, "replacement", valuetable) ) {
                curr = cs.ocap[cs.cap - 1].s + cs.ocap[cs.cap - 1].siz - 1; // continue after match
            } else {
                // no capture value
                curr = next; // keep original text in final result
            }
        }
        b[#b + 1] = cs.s && cs.s->sub(curr, curr + cs.ocap[cs.cap].s - curr - 1) ||
                cs.stream(curr, curr + cs.ocap[cs.cap].s - curr - 1); // add last piece of text
    }
    cs.cap = cs.cap + 1; // go to next capture
}


// Evaluates a capture and adds its first value to buffer 'b'; returns
// whether there was a value

function addonestring(cs, b, what, valuetable) {
    var tag = cs.ocap[cs.cap].kind;
    if( tag == Cstring ) {
        stringcap(cs, b, valuetable); // add capture directly to buffer
        return 1;
    } else if( tag == Csubst ) {
        substcap(cs, b, valuetable); // add capture directly to buffer
        return 1;
    } else {
        var subout = { outindex = 0, out = {} };
        var n = pushcapture(cs, subout, valuetable);
        if( n > 0 ) {
            if( type(subout.out[1]) != 'string' && type(subout.out[1]) != 'number' ) {
                error(("invalid %s value (a %s)")->format(what, type(subout.out[1])), 0);
            }
            b[#b + 1] = subout.out[1];
            return n;
        }
    }
}


// Push all values of the current capture into the stack; returns
// number of values pushed

function pushcapture(cs, out, valuetable) {
    var type = cs.ocap[cs.cap].kind;
    if( type == Cposition ) {
        out.outindex = out.outindex + 1;
        out.out[out.outindex] = cs.ocap[cs.cap].s;
        cs.cap = cs.cap + 1;
        return 1;
    } else if( type == Cconst ) {
        out.outindex = out.outindex + 1;
        out.out[out.outindex] = valuetable[cs.ocap[cs.cap].idx];
        cs.cap = cs.cap + 1;
        return 1;
    } else if( type == Carg ) {
        var arg = valuetable[cs.ocap[cs.cap].idx];
        cs.cap = cs.cap + 1;
        if( arg > cs.ptopcount ) {
            error(("reference to absent extra argument #%d")->format(arg), 0);
        }
        out.outindex = out.outindex + 1;
        out.out[out.outindex] = cs.ptop[arg];
        return 1;
    } else if( type == Csimple ) {
        var k = pushnestedvalues(cs, true, out, valuetable);
        var index = out.outindex;
        table.insert(out.out, index - k + 1, out.out[index]);
        out[index + 1] = null;
        return k;
    } else if( type == Cruntime ) {
        out.outindex = out.outindex + 1;
        out.out[out.outindex] = valuetable[cs.ocap[cs.cap].idx];
        cs.cap = cs.cap + 1;
        return 1;
    } else if( type == Cstring ) {
        var b = {};
        stringcap(cs, b, valuetable);
        out.outindex = out.outindex + 1;
        out.out[out.outindex] = table.concat(b);
        return 1;
    } else if( type == Csubst ) {
        var b = {};
        substcap(cs, b, valuetable);
        out.outindex = out.outindex + 1;
        out.out[out.outindex] = table.concat(b);
        return 1;
    } else if( type == Cgroup ) {
        // anonymous group?
        if( cs.ocap[cs.cap].idx == 0 ) {
            return pushnestedvalues(cs, false, out, valuetable); // add all nested values
        } else {
            // named group: add no values
            nextcap(cs); // skip capture
            return 0;
        }
    } else if( type == Cbackref ) {
        return backrefcap(cs, out, valuetable);
    } else if( type == Ctable ) {
        return tablecap(cs, out, valuetable);
    } else if( type == Cfunction ) {
        return functioncap(cs, out, valuetable);
    } else if( type == Cnum ) {
        return numcap(cs, out, valuetable);
    } else if( type == Cquery ) {
        return querycap(cs, out, valuetable);
    } else if( type == Cfold ) {
        return foldcap(cs, out, valuetable);
    } else {
        assert(false);
    }
}


// Prepare a CapState structure and traverse the entire list of
// captures in the stack pushing its results. 's' is the subject
// string, 'r' is the final position of the match, and 'ptop'
// the index in the stack where some useful values were pushed.
// Returns the number of results pushed. (If the list produces no
// results, push the final position of the match.)

var function getcaptures(capture, s, stream, r, valuetable, ...) {
    var n = 0;
    var cs = { cap = 0 };
    var out = { outindex = 0; out = {} };
    // is there any capture?
    if( capture[cs.cap].kind != Cclose ) {
        cs.ocap = capture;
        cs.s = s;
        cs.stream = stream;
        cs.ptopcount, cs.ptop = retcount(...);
        do { // collect their values
            n += pushcapture(cs, out, valuetable);
        } while(!( cs.ocap[cs.cap].kind == Cclose) );
    }
    // no capture values?
    if( n == 0 ) {
        if( ! r ) {
            return;
        } else {
            return r;
        }
    }
    assert(out.outindex < 7998, "(too many captures)");
    return unpack(out.out, 1, out.outindex);
}

var function getcapturesruntime(capture, s, stream, notdelete, min, max, captop, valuetable, ...) {
    var n = 0;
    var cs = { cap = min };
    var out = { outindex = 0; out = {} };
    cs.ocap = capture;
    cs.s = s;
    cs.stream = stream;
    cs.ptopcount, cs.ptop = retcount(...);
    var start = 0;
    do { // collect their values
        if( ! checknextcap(cs, max) ) { break; }
        var xnotdelete = notdelete || capture[cs.cap].kind == Cgroup && capture[cs.cap].idx != 0 && capture[cs.cap].candelete == 0;
        pushcapture(cs, out, valuetable);
        if( xnotdelete ) {
            start = cs.cap;
        } else {
            n = n + cs.cap - start;
            for( i = 0, captop - cs.cap - 1 ) {
                ffi.copy(capture + start + i, capture + cs.cap + i, ffi.sizeof('CAPTURE'));
            }
            max = max - (cs.cap - start);
            captop = captop - (cs.cap - start);
            cs.cap = start;
        }
    } while(!( cs.cap == max) );
    assert(out.outindex < 7998, "(too many captures)");
    return n, out.out, out.outindex;
}

return {
    getcaptures = getcaptures,
    runtimecap = runtimecap,
    getcapturesruntime = getcapturesruntime,
};

