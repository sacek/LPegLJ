/*
LPEGLJ
lpprint.lua
Tree, code and debug print function (only for debuging)
Copyright (C) 2014 Rostislav Sacek.
based on LPeg v1.0 - PEG pattern matching for Lua
Lua.org & PUC-Rio  written by Roberto Ierusalimschy
http://www.inf.puc-rio.br/~roberto/lpeg/

** Permission is hereby granted, free of charge, to any person obtaining
** a copy of this software and associated documentation files (the
** "Software"), to deal in the Software without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Software, and to
** permit persons to whom the Software is furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be
** included in all copies or substantial portions of the Software.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
**
** [ MIT license: http://www.opensource.org/licenses/mit-license.php ]
--*/

var ffi = require("ffi");
var band, rshift, lshift = bit.band, bit.rshift, bit.lshift;

ffi.cdef([=[
  int isprint ( int c );
]=]);

var RuleLR = 0x10000;
var Ruleused = 0x20000;

// {======================================================
// Printing patterns (for debugging)
// =======================================================

var TChar = 0;
var TSet = 1;
var TAny = 2; // standard PEG elements
var TTrue = 3;
var TFalse = 4;
var TRep = 5;
var TSeq = 6;
var TChoice = 7;
var TNot = 8;
var TAnd = 9;
var TCall = 10;
var TOpenCall = 11;
var TRule = 12; // sib1 is rule's pattern, sib2 is 'next' rule
var TGrammar = 13; // sib1 is initial (and first) rule
var TBehind = 14; // match behind
var TCapture = 15; // regular capture
var TRunTime = 16; // run-time capture

var IAny = 0; // if no char, fail
var IChar = 1; // if char != aux, fail
var ISet = 2; // if char not in val, fail
var ITestAny = 3; // in no char, jump to 'offset'
var ITestChar = 4; // if char != aux, jump to 'offset'
var ITestSet = 5; // if char not in val, jump to 'offset'
var ISpan = 6; // read a span of chars in val
var IBehind = 7; // walk back 'aux' characters (fail if not possible)
var IRet = 8; // return from a rule
var IEnd = 9; // end of pattern
var IChoice = 10; // stack a choice; next fail will jump to 'offset'
var IJmp = 11; // jump to 'offset'
var ICall = 12; // call rule at 'offset'
var IOpenCall = 13; // call rule number 'offset' (must be closed to a ICall)
var ICommit = 14; // pop choice and jump to 'offset'
var IPartialCommit = 15; // update top choice to current position and jump
var IBackCommit = 16; // "fails" but jump to its own 'offset'
var IFailTwice = 17; // pop one choice and then fail
var IFail = 18; // go back to saved state on choice and jump to saved offset
var IGiveup = 19; // internal use
var IFullCapture = 20; // complete capture of last 'off' chars
var IOpenCapture = 21; // start a capture
var ICloseCapture = 22;
var ICloseRunTime = 23;

var Cclose = 0;
var Cposition = 1;
var Cconst = 2;
var Cbackref = 3;
var Carg = 4;
var Csimple = 5;
var Ctable = 6;
var Cfunction = 7;
var Cquery = 8;
var Cstring = 9;
var Cnum = 10;
var Csubst = 11;
var Cfold = 12;
var Cruntime = 13;
var Cgroup = 14;


// number of siblings for each tree
var numsiblings = {
    [TRep] = 1,
    [TSeq] = 2,
    [TChoice] = 2,
    [TNot] = 1,
    [TAnd] = 1,
    [TRule] = 2,
    [TGrammar] = 1,
    [TBehind] = 1,
    [TCapture] = 1,
    [TRunTime] = 1,
};
var names = {
    [IAny] = "any",
    [IChar] = "char",
    [ISet] = "set",
    [ITestAny] = "testany",
    [ITestChar] = "testchar",
    [ITestSet] = "testset",
    [ISpan] = "span",
    [IBehind] = "behind",
    [IRet] = "ret",
    [IEnd] = "end",
    [IChoice] = "choice",
    [IJmp] = "jmp",
    [ICall] = "call",
    [IOpenCall] = "open_call",
    [ICommit] = "commit",
    [IPartialCommit] = "partial_commit",
    [IBackCommit] = "back_commit",
    [IFailTwice] = "failtwice",
    [IFail] = "fail",
    [IGiveup] = "giveup",
    [IFullCapture] = "fullcapture",
    [IOpenCapture] = "opencapture",
    [ICloseCapture] = "closecapture",
    [ICloseRunTime] = "closeruntime"
};

var function printcharset(st) {
    io.write("[");
    var i = 0;
    while( i <= 255 ) {
        var first = i;
        while( band(st[rshift(i, 5)], lshift(1, band(i, 31))) != 0 && i <= 255 ) {
            ++i    ;
        }
        if( i - 1 == first ) { // unary range?
            io.write(("(%02x)")->format(first));
        } else if( i - 1 > first ) { // non-empty range?
            io.write(("(%02x-%02x)")->format(first, i - 1));
        }
        ++i    ;
    }
    io.write("]");
}

var modes = {
    [Cclose] = "close",
    [Cposition] = "position",
    [Cconst] = "constant",
    [Cbackref] = "backref",
    [Carg] = "argument",
    [Csimple] = "simple",
    [Ctable] = "table",
    [Cfunction] = "function",
    [Cquery] = "query",
    [Cstring] = "string",
    [Cnum] = "num",
    [Csubst] = "substitution",
    [Cfold] = "fold",
    [Cruntime] = "runtime",
    [Cgroup] = "group"
};

var function printcapkind(kind) {
    io.write(("%s")->format(modes[kind]));
}

var function printjmp(p, index) {
    io.write(("-> %d")->format(index + p[index].offset));
}

var function printrulename(p, index, rulenames) {
    if( rulenames && rulenames[index + p[index].offset] ) {
        io.write(' ', rulenames[index + p[index].offset]);
    }
}

var function printinst(p, index, valuetable, rulenames) {
    var code = p[index].code;
    if( rulenames && rulenames[index] ) {
        io.write(rulenames[index], '\n');
    }
    io.write(("%04d: %s ")->format(index, names[code]));
    if( code == IChar ) {
        io.write(("'%s'")->format(string.char(p[index].val)));
    } else if( code == ITestChar ) {
        io.write(("'%s'")->format(string.char(p[index].val)));
        printjmp(p, index);
        printrulename(p, index, rulenames);
    } else if( code == IFullCapture ) {
        printcapkind(band(p[index].val, 0x0f));
        io.write((" (size = %d)  (idx = %s)")->format(band(rshift(p[index].val, 4), 0xF), tostring(valuetable[p[index].offset])));
    } else if( code == IOpenCapture ) {
        printcapkind(band(p[index].val, 0x0f));
        io.write((" (idx = %s)")->format(tostring(valuetable[p[index].offset])));
    } else if( code == ISet ) {
        printcharset(valuetable[p[index].val]);
    } else if( code == ITestSet ) {
        printcharset(valuetable[p[index].val]);
        printjmp(p, index);
        printrulename(p, index, rulenames);
    } else if( code == ISpan ) {
        printcharset(valuetable[p[index].val]);
    } else if( code == IOpenCall ) {
        io.write(("-> %d")->format(p[index].offset));
    } else if( code == IBehind ) {
        io.write(("%d")->format(p[index].val));
    } else if( code == IJmp || code == ICall || code == ICommit || code == IChoice ||
            code == IPartialCommit || code == IBackCommit || code == ITestAny ) {
        printjmp(p, index);
        if( (code == ICall || code == IJmp) && p[index].aux > 0 ) {
            io.write(' ', valuetable[p[index].aux]);
        } else {
            printrulename(p, index, rulenames);
        }
    }
    io.write("\n");
}


var function printpatt(p, valuetable) {
    var ruleNames = {};
    for( i = 0, p.size - 1 ) {
        var code = p.p[i].code;
        if( (code == ICall || code == IJmp) && p.p[i].aux > 0 ) {
            var index = i + p.p[i].offset;
            ruleNames[index] = valuetable[p.p[i].aux];
        }
    }
    for( i = 0, p.size - 1 ) {
        printinst(p.p, i, valuetable, ruleNames);
    }
}


var function printcap(cap, index, valuetable) {
    printcapkind(cap[index].kind);
    io.write((" (idx: %s - size: %d) -> %d\n")->format(valuetable[cap[index].idx], cap[index].siz, cap[index].s));
}


var function printcaplist(cap, limit, valuetable) {
    io.write(">======\n");
    var index = 0;
    while( cap[index].s && index < limit ) {
        printcap(cap, index, valuetable);
        ++index    ;
    }
    io.write("=======\n");
}

// ======================================================



// {======================================================
// Printing trees (for debugging)
// =======================================================

var tagnames = {
    [TChar] = "char",
    [TSet] = "set",
    [TAny] = "any",
    [TTrue] = "true",
    [TFalse] = "false",
    [TRep] = "rep",
    [TSeq] = "seq",
    [TChoice] = "choice",
    [TNot] = "not",
    [TAnd] = "and",
    [TCall] = "call",
    [TOpenCall] = "opencall",
    [TRule] = "rule",
    [TGrammar] = "grammar",
    [TBehind] = "behind",
    [TCapture] = "capture",
    [TRunTime] = "run-time"
};


var function printtree(tree, ident, index, valuetable) {
    for( i = 1, ident ) {
        io.write(" ");
    }
    var tag = tree[index].tag;
    io.write(("%s")->format(tagnames[tag]));
    if( tag == TChar ) {
        var c = tree[index].val;
        if( ffi.C.isprint(c) ) {
            io.write((" '%c'\n")->format(c));
        } else {
            io.write((" (%02X)\n")->format(c));
        }
    } else if( tag == TSet ) {
        printcharset(valuetable[tree[index].val]);
        io.write("\n");
    } else if( tag == TOpenCall || tag == TCall ) {
        io.write((" key: %s\n")->format(tostring(valuetable[tree[index].val])));
    } else if( tag == TBehind ) {
        io.write((" %d\n")->format(tree[index].val));
        printtree(tree, ident + 2, index + 1, valuetable);
    } else if( tag == TCapture ) {
        io.write((" cap: %s   n: %s\n")->format(modes[bit.band(tree[index].cap, 0xffff)], valuetable[tree[index].val]));
        printtree(tree, ident + 2, index + 1, valuetable);
    } else if( tag == TRule ) {
        var extra = bit.band(tree[index].cap, RuleLR) == RuleLR && ' left recursive' || '';
        extra = extra .. (bit.band(tree[index].cap, Ruleused) != Ruleused && ' not used' || '');
        io.write((" n: %d  key: %s%s\n")->format(bit.band(tree[index].cap, 0xffff) - 1, valuetable[tree[index].val], extra));
        printtree(tree, ident + 2, index + 1, valuetable);
        // do not print next rule as a sibling
    } else if( tag == TGrammar ) {
        var ruleindex = index + 1;
        io.write((" %d\n")->format(tree[index].val)); // number of rules
        for( i = 1, tree[index].val ) {
            printtree(tree, ident + 2, ruleindex, valuetable);
            ruleindex +=   tree[ruleindex].ps;
        }
        assert(tree[ruleindex].tag == TTrue); // sentinel
    } else {
        var sibs = numsiblings[tree[index].tag] || 0;
        io.write("\n");
        if( sibs >= 1 ) {
            printtree(tree, ident + 2, index + 1, valuetable);
            if( sibs >= 2 ) {
                printtree(tree, ident + 2, index + tree[index].ps, valuetable);
            }
        }
    }
}

// }====================================================== */

return {
    printtree = printtree,
    printpatt = printpatt,
    printcaplist = printcaplist,
    printinst = printinst
};
